import os
import re
from yt_dlp import YoutubeDL
import hashlib
import json
from datetime import datetime

def get_default_music_dir():
    """Devuelve la ruta del directorio de MÃºsica predeterminado del sistema."""
    home_dir = os.path.expanduser("~")
    return os.path.join(home_dir, "Music")

def get_metadata_file():
    """Devuelve la ruta del archivo de metadatos para rastrear canciones."""
    music_dir = get_default_music_dir()
    return os.path.join(music_dir, ".music_metadata.json")

def load_metadata():
    """Carga los metadatos de canciones descargadas."""
    metadata_file = get_metadata_file()
    if os.path.exists(metadata_file):
        try:
            with open(metadata_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_metadata(metadata):
    """Guarda los metadatos de canciones descargadas."""
    metadata_file = get_metadata_file()
    try:
        with open(metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
    except Exception as e:
        print(f"âš ï¸ No se pudo guardar metadatos: {e}")

def get_video_id(url):
    """Extrae el ID del video de YouTube de la URL."""
    patterns = [
        r'(?:youtube\.com/watch\?v=|youtu\.be/|youtube\.com/embed/)([^&\n?#]+)',
        r'youtube\.com/watch\?.*v=([^&\n?#]+)'
    ]
    
    for pattern in patterns:
        match = re.search(pattern, url)
        if match:
            return match.group(1)
    return None

def check_duplicate_by_id(video_id, metadata):
    """Verifica si ya existe una canciÃ³n con el mismo ID de video."""
    for entry in metadata.values():
        if entry.get('video_id') == video_id:
            return entry
    return None

def check_duplicate_by_title(artist, song_title, metadata):
    """Verifica si ya existe una canciÃ³n con el mismo tÃ­tulo y artista."""
    for filepath, entry in metadata.items():
        if (entry.get('artist', '').lower() == artist.lower() and 
            entry.get('song_title', '').lower() == song_title.lower()):
            return entry
    return None

def file_exists(filepath):
    """Verifica si el archivo fÃ­sico existe."""
    return os.path.exists(filepath)

def sanitize_filename(filename):
    """Limpia el nombre del archivo eliminando caracteres no vÃ¡lidos."""
    filename = re.sub(r'[<>:"/\\|?*]', '', filename)
    filename = filename.strip()
    filename = re.sub(r'\s+', ' ', filename)
    return filename

def extract_artist_from_title(title):
    """Extrae el nombre del artista del tÃ­tulo del video."""
    patterns = [
        r'^([^-]+)\s*-\s*(.+)$',
        r'^([^â€“]+)\s*â€“\s*(.+)$',
        r'^([^|]+)\s*\|\s*(.+)$',
        r'^([^â€¢]+)\s*â€¢\s*(.+)$',
    ]
    
    for pattern in patterns:
        match = re.match(pattern, title)
        if match:
            artist = match.group(1).strip()
            song = match.group(2).strip()
            return sanitize_filename(artist), sanitize_filename(song)
    
    return "Artista Desconocido", sanitize_filename(title)

def handle_duplicate(existing_entry, new_title, new_artist, action_choice=None):
    """Maneja el caso cuando se encuentra un duplicado."""
    print(f"\nâš ï¸  DUPLICADO DETECTADO:")
    print(f"   ğŸµ CanciÃ³n: {existing_entry.get('song_title', 'N/A')}")
    print(f"   ğŸ¤ Artista: {existing_entry.get('artist', 'N/A')}")
    print(f"   ğŸ“ UbicaciÃ³n: {existing_entry.get('filepath', 'N/A')}")
    print(f"   ğŸ“… Descargada: {existing_entry.get('download_date', 'N/A')}")
    
    if action_choice is None:
        print(f"\nÂ¿QuÃ© deseas hacer?")
        print("1. Omitir descarga (mantener archivo existente)")
        print("2. Reemplazar archivo existente")
        print("3. Descargar con nuevo nombre")
        print("4. Cancelar operaciÃ³n")
        
        while True:
            choice = input("Selecciona una opciÃ³n (1-4): ").strip()
            if choice in ['1', '2', '3', '4']:
                break
            print("Por favor, selecciona 1, 2, 3 o 4.")
    else:
        choice = action_choice
    
    return choice

def add_to_metadata(filepath, video_id, artist, song_title, video_title, uploader):
    """AÃ±ade una entrada a los metadatos."""
    metadata = load_metadata()
    metadata[filepath] = {
        'video_id': video_id,
        'artist': artist,
        'song_title': song_title,
        'video_title': video_title,
        'uploader': uploader,
        'download_date': datetime.now().isoformat(),
        'filepath': filepath
    }
    save_metadata(metadata)

def download_mp3(url, organize_by_artist=True, duplicate_action=None):
    """
    Descarga audio de un video o playlist de YouTube como MP3.
    duplicate_action: 'skip', 'replace', 'rename', 'cancel' para manejo automÃ¡tico de duplicados
    """
    music_dir = get_default_music_dir()
    metadata = load_metadata()
    
    # Extraer ID del video
    video_id = get_video_id(url)
    if not video_id:
        print("âŒ No se pudo extraer el ID del video de la URL.")
        return False
    
    # Obtener informaciÃ³n del video
    ydl_info_opts = {
        'quiet': True,
        'no_warnings': True,
    }
    
    try:
        with YoutubeDL(ydl_info_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            
            if 'entries' in info:
                print(f"ğŸµ Playlist detectada: {info.get('title', 'Sin tÃ­tulo')}")
                print(f"ğŸ“Š NÃºmero de canciones: {len(info['entries'])}")
                
                confirm = input("Â¿Continuar con la descarga de toda la playlist? (s/n): ").lower().strip()
                if confirm not in ['s', 'si', 'sÃ­', 'y', 'yes']:
                    print("Descarga cancelada.")
                    return False
                
                return download_playlist(url, organize_by_artist, duplicate_action)
            else:
                video_title = info.get('title', 'TÃ­tulo Desconocido')
                uploader = info.get('uploader', 'Canal Desconocido')
    except Exception as e:
        print(f"âŒ Error al obtener informaciÃ³n del video: {e}")
        return False
    
    # Verificar duplicados por ID de video
    duplicate_by_id = check_duplicate_by_id(video_id, metadata)
    if duplicate_by_id:
        if file_exists(duplicate_by_id.get('filepath', '')):
            action = handle_duplicate(duplicate_by_id, video_title, uploader, duplicate_action)
            if action == '1':  # Omitir
                print("â­ï¸  Descarga omitida.")
                return True
            elif action == '4':  # Cancelar
                print("âŒ OperaciÃ³n cancelada.")
                return False
            elif action == '2':  # Reemplazar
                # Eliminar archivo existente
                try:
                    os.remove(duplicate_by_id.get('filepath', ''))
                    print("ğŸ—‘ï¸  Archivo existente eliminado.")
                except:
                    pass
    
    # Determinar rutas de descarga
    if organize_by_artist:
        artist, song_title = extract_artist_from_title(video_title)
        if artist == "Artista Desconocido":
            artist = sanitize_filename(uploader)
        
        # Verificar duplicados por tÃ­tulo y artista
        duplicate_by_title = check_duplicate_by_title(artist, song_title, metadata)
        if duplicate_by_title and not duplicate_by_id:
            if file_exists(duplicate_by_title.get('filepath', '')):
                action = handle_duplicate(duplicate_by_title, song_title, artist, duplicate_action)
                if action == '1':  # Omitir
                    print("â­ï¸  Descarga omitida.")
                    return True
                elif action == '4':  # Cancelar
                    print("âŒ OperaciÃ³n cancelada.")
                    return False
                elif action == '2':  # Reemplazar
                    try:
                        os.remove(duplicate_by_title.get('filepath', ''))
                        print("ğŸ—‘ï¸  Archivo existente eliminado.")
                    except:
                        pass
                elif action == '3':  # Nuevo nombre
                    counter = 1
                    base_song_title = song_title
                    while True:
                        song_title = f"{base_song_title} ({counter})"
                        if not check_duplicate_by_title(artist, song_title, metadata):
                            break
                        counter += 1
                    print(f"ğŸ“ Nuevo nombre: {song_title}")
        
        artist_dir = os.path.join(music_dir, artist)
        output_template = os.path.join(artist_dir, f"{song_title}.mp3")
    else:
        song_title = sanitize_filename(video_title)
        artist = sanitize_filename(uploader)
        output_template = os.path.join(music_dir, f"{song_title}.mp3")
    
    # Crear directorio si no existe
    output_dir = os.path.dirname(output_template)
    try:
        os.makedirs(output_dir, exist_ok=True)
    except PermissionError:
        print(f"âŒ Sin permisos para crear/escribir en '{output_dir}'.")
        return False
    except Exception as e:
        print(f"âŒ Error inesperado: {e}")
        return False
    
    # ConfiguraciÃ³n de descarga
    ydl_opts = {
        'format': 'bestaudio/best',
        'outtmpl': output_template,
        'postprocessors': [{
            'key': 'FFmpegExtractAudio',
            'preferredcodec': 'mp3',
            'preferredquality': '192',
        }],
        'quiet': True,
        'no_warnings': True,
    }
    
    # Mostrar informaciÃ³n
    if organize_by_artist:
        print(f"ğŸµ Descargando: {song_title}")
        print(f"ğŸ¤ Artista: {artist}")
        print(f"ğŸ“ Guardando en: {output_dir}")
    else:
        print(f"ğŸµ Descargando: {video_title}")
        print(f"ğŸ“ Guardando en: {music_dir}")
    
    # Descargar
    try:
        with YoutubeDL(ydl_opts) as ydl:
            ydl.download([url])
        
        # AÃ±adir a metadatos
        add_to_metadata(output_template, video_id, artist, song_title, video_title, uploader)
        print("âœ… Â¡Descarga completada exitosamente!")
        return True
    except Exception as e:
        print(f"âŒ Error en la descarga: {e}")
        return False

def download_playlist(url, organize_by_artist=True, duplicate_action=None):
    """Descarga una playlist completa con manejo de duplicados."""
    print("ğŸµ Procesando playlist...")
    
    # Obtener informaciÃ³n de la playlist
    ydl_info_opts = {'quiet': True, 'no_warnings': True}
    
    try:
        with YoutubeDL(ydl_info_opts) as ydl:
            playlist_info = ydl.extract_info(url, download=False)
            entries = playlist_info.get('entries', [])
    except Exception as e:
        print(f"âŒ Error al obtener informaciÃ³n de la playlist: {e}")
        return False
    
    if not entries:
        print("âŒ No se encontraron videos en la playlist.")
        return False
    
    # Preguntar acciÃ³n para duplicados si no se especificÃ³
    if duplicate_action is None:
        print(f"\nÂ¿CÃ³mo manejar duplicados durante la descarga de la playlist?")
        print("1. Omitir duplicados automÃ¡ticamente")
        print("2. Reemplazar duplicados automÃ¡ticamente")
        print("3. Preguntar para cada duplicado")
        
        while True:
            choice = input("Selecciona una opciÃ³n (1-3): ").strip()
            if choice == '1':
                duplicate_action = '1'
                break
            elif choice == '2':
                duplicate_action = '2'
                break
            elif choice == '3':
                duplicate_action = None
                break
            else:
                print("Por favor, selecciona 1, 2 o 3.")
    
    success_count = 0
    skip_count = 0
    error_count = 0
    
    for i, entry in enumerate(entries, 1):
        if entry is None:
            continue
            
        video_url = entry.get('webpage_url') or f"https://www.youtube.com/watch?v={entry.get('id')}"
        video_title = entry.get('title', f'Video {i}')
        
        print(f"\n[{i}/{len(entries)}] {video_title}")
        
        result = download_mp3(video_url, organize_by_artist, duplicate_action)
        
        if result is True:
            success_count += 1
        elif result is False:
            error_count += 1
        else:
            skip_count += 1
    
    print(f"\nğŸ‰ Playlist procesada:")
    print(f"   âœ… Descargadas: {success_count}")
    print(f"   â­ï¸  Omitidas: {skip_count}")
    print(f"   âŒ Errores: {error_count}")
    
    return True

def reorganize_existing_music():
    """Reorganiza canciones existentes y actualiza metadatos."""
    music_dir = get_default_music_dir()
    
    if not os.path.exists(music_dir):
        print(f"âŒ No se encontrÃ³ el directorio de mÃºsica: {music_dir}")
        return
    
    # Buscar archivos MP3 en el directorio raÃ­z
    mp3_files = []
    for file in os.listdir(music_dir):
        if file.lower().endswith('.mp3') and os.path.isfile(os.path.join(music_dir, file)):
            mp3_files.append(file)
    
    if not mp3_files:
        print("ğŸ“ No se encontraron archivos MP3 para reorganizar.")
        return
    
    print(f"ğŸµ Encontrados {len(mp3_files)} archivos MP3 para reorganizar:")
    for i, file in enumerate(mp3_files[:5], 1):
        print(f"  {i}. {file}")
    if len(mp3_files) > 5:
        print(f"  ... y {len(mp3_files) - 5} mÃ¡s")
    
    confirm = input("\nÂ¿Proceder con la reorganizaciÃ³n? (s/n): ").lower().strip()
    if confirm not in ['s', 'si', 'sÃ­', 'y', 'yes']:
        print("ReorganizaciÃ³n cancelada.")
        return
    
    metadata = load_metadata()
    moved_count = 0
    error_count = 0
    
    for filename in mp3_files:
        try:
            title = filename[:-4]  # Quitar '.mp3'
            artist, song_title = extract_artist_from_title(title)
            
            artist_dir = os.path.join(music_dir, artist)
            os.makedirs(artist_dir, exist_ok=True)
            
            old_path = os.path.join(music_dir, filename)
            new_filename = f"{song_title}.mp3"
            new_path = os.path.join(artist_dir, new_filename)
            
            if os.path.exists(new_path):
                print(f"âš ï¸  Ya existe: {artist}/{new_filename}")
                continue
            
            os.rename(old_path, new_path)
            print(f"âœ… Movido: {filename} â†’ {artist}/{new_filename}")
            
            # Actualizar metadatos
            add_to_metadata(new_path, None, artist, song_title, title, "Desconocido")
            moved_count += 1
            
        except Exception as e:
            print(f"âŒ Error con {filename}: {e}")
            error_count += 1
    
    print(f"\nğŸ‰ ReorganizaciÃ³n completada:")
    print(f"   âœ… Archivos movidos: {moved_count}")
    if error_count > 0:
        print(f"   âŒ Errores: {error_count}")

def show_duplicates():
    """Muestra informaciÃ³n sobre duplicados detectados."""
    metadata = load_metadata()
    if not metadata:
        print("ğŸ“ No hay metadatos disponibles.")
        return
    
    print(f"\nğŸ“Š RESUMEN DE MÃšSICA DESCARGADA:")
    print(f"   ğŸµ Total de canciones: {len(metadata)}")
    
    # Agrupar por artista
    artists = {}
    for entry in metadata.values():
        artist = entry.get('artist', 'Desconocido')
        if artist not in artists:
            artists[artist] = []
        artists[artist].append(entry)
    
    print(f"   ğŸ¤ Artistas Ãºnicos: {len(artists)}")
    
    # Mostrar top 10 artistas
    sorted_artists = sorted(artists.items(), key=lambda x: len(x[1]), reverse=True)
    print(f"\nğŸ† TOP 10 ARTISTAS:")
    for i, (artist, songs) in enumerate(sorted_artists[:10], 1):
        print(f"   {i:2d}. {artist}: {len(songs)} canciones")
    
    # Verificar archivos faltantes
    missing_files = []
    for filepath, entry in metadata.items():
        if not os.path.exists(filepath):
            missing_files.append((filepath, entry))
    
    if missing_files:
        print(f"\nâš ï¸  ARCHIVOS FALTANTES ({len(missing_files)}):")
        for filepath, entry in missing_files[:5]:
            print(f"   ğŸ“ {filepath}")
        if len(missing_files) > 5:
            print(f"   ... y {len(missing_files) - 5} mÃ¡s")

def cleanup_metadata():
    """Limpia metadatos de archivos que ya no existen."""
    metadata = load_metadata()
    if not metadata:
        print("ğŸ“ No hay metadatos para limpiar.")
        return
    
    original_count = len(metadata)
    cleaned_metadata = {}
    
    for filepath, entry in metadata.items():
        if os.path.exists(filepath):
            cleaned_metadata[filepath] = entry
    
    removed_count = original_count - len(cleaned_metadata)
    
    if removed_count > 0:
        save_metadata(cleaned_metadata)
        print(f"ğŸ§¹ Limpieza completada:")
        print(f"   ğŸ“ Entradas eliminadas: {removed_count}")
        print(f"   ğŸ“ Entradas restantes: {len(cleaned_metadata)}")
    else:
        print("âœ… No se encontraron entradas para limpiar.")

def show_menu():
    """Muestra el menÃº principal."""
    print("\n" + "="*60)
    print("ğŸµ DESCARGADOR DE YOUTUBE A MP3 - VERSIÃ“N MEJORADA")
    print("="*60)
    print("1. Descargar video individual")
    print("2. Descargar playlist completa")
    print("3. Reorganizar mÃºsica existente")
    print("4. Ver estadÃ­sticas y duplicados")
    print("5. Limpiar metadatos")
    print("6. Salir")
    print("="*60)

def download_multiple_songs():
    """FunciÃ³n principal con menÃº mejorado."""
    print("ğŸµ Â¡Bienvenido al Descargador de YouTube MP3!")
    
    # ConfiguraciÃ³n inicial
    while True:
        organize = input("Â¿Organizar canciones por artista en carpetas? (s/n): ").lower().strip()
        if organize in ['s', 'si', 'sÃ­', 'y', 'yes']:
            organize_by_artist = True
            break
        elif organize in ['n', 'no']:
            organize_by_artist = False
            break
        else:
            print("Por favor, responde 's' para sÃ­ o 'n' para no.")
    
    while True:
        show_menu()
        choice = input("Selecciona una opciÃ³n (1-6): ").strip()
        
        if choice == '1':
            url = input("\nğŸ“¹ Ingresa la URL del video de YouTube: ").strip()
            if url and ('youtube.com' in url or 'youtu.be' in url):
                print("ğŸš€ Iniciando descarga...")
                download_mp3(url, organize_by_artist)
            else:
                print("âŒ URL no vÃ¡lida.")
        
        elif choice == '2':
            url = input("\nğŸ“‹ Ingresa la URL de la playlist de YouTube: ").strip()
            if url and 'youtube.com' in url and ('playlist' in url or 'list=' in url):
                print("ğŸš€ Analizando playlist...")
                download_mp3(url, organize_by_artist)
            else:
                print("âŒ URL de playlist no vÃ¡lida.")
        
        elif choice == '3':
            print("\nğŸ“ Reorganizando mÃºsica existente...")
            reorganize_existing_music()
        
        elif choice == '4':
            show_duplicates()
        
        elif choice == '5':
            print("\nğŸ§¹ Limpiando metadatos...")
            cleanup_metadata()
        
        elif choice == '6':
            print("\nğŸ‘‹ Â¡Hasta luego!")
            break
        
        else:
            print("âŒ OpciÃ³n no vÃ¡lida. Por favor, selecciona 1-6.")
        
        input("\nPresiona Enter para continuar...")

if __name__ == "__main__":
    download_multiple_songs()